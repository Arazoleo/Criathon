<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Assembly Quest - Menu Principal</title>
  <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Rajdhani:wght@300;400;600;700&display=swap" rel="stylesheet">
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: 'Rajdhani', sans-serif;
      background: #000;
      color: #fff;
      overflow: hidden;
      height: 100vh;
    }

    #canvas {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 1;
    }

    .menu-container {
      position: relative;
      z-index: 10;
      height: 100vh;
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      padding: 2rem;
    }

    .logo {
      font-family: 'Orbitron', monospace;
      font-size: clamp(3rem, 8vw, 6rem);
      font-weight: 900;
      text-align: center;
      margin-bottom: 2rem;
      background: linear-gradient(45deg, #00ff41, #00aaff, #ff00ff, #ffff00);
      background-size: 400% 400%;
      -webkit-background-clip: text;
      -webkit-text-fill-color: transparent;
      background-clip: text;
      animation: gradientShift 3s ease-in-out infinite;
      text-shadow: 0 0 30px rgba(0, 255, 65, 0.5);
      filter: drop-shadow(0 0 20px rgba(0, 255, 65, 0.3));
    }

    @keyframes gradientShift {
      0%, 100% { background-position: 0% 50%; }
      50% { background-position: 100% 50%; }
    }

    .subtitle {
      font-size: clamp(1rem, 3vw, 1.5rem);
      color: #00aaff;
      text-align: center;
      margin-bottom: 4rem;
      font-weight: 300;
      letter-spacing: 2px;
      opacity: 0.8;
    }

    .menu-buttons {
      display: flex;
      flex-direction: column;
      gap: 1.5rem;
      align-items: center;
      width: 100%;
      max-width: 400px;
    }

    .menu-btn {
      width: 100%;
      padding: 1rem 2rem;
      font-family: 'Orbitron', monospace;
      font-size: 1.2rem;
      font-weight: 600;
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.1), rgba(0, 170, 255, 0.1));
      border: 2px solid transparent;
      border-radius: 15px;
      color: #fff;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
      overflow: hidden;
      backdrop-filter: blur(10px);
      text-transform: uppercase;
      letter-spacing: 1px;
    }

    .menu-btn::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.2), transparent);
      transition: left 0.5s;
    }

    .menu-btn:hover::before {
      left: 100%;
    }

    .menu-btn:hover {
      border-color: #00ff41;
      box-shadow: 
        0 0 20px rgba(0, 255, 65, 0.4),
        inset 0 0 20px rgba(0, 255, 65, 0.1);
      transform: translateY(-2px);
      background: linear-gradient(135deg, rgba(0, 255, 65, 0.2), rgba(0, 170, 255, 0.2));
    }

    .menu-btn:active {
      transform: translateY(0);
    }

    .menu-btn.primary {
      background: linear-gradient(135deg, #00ff41, #00cc33);
      color: #000;
      font-weight: 700;
    }

    .menu-btn.primary:hover {
      background: linear-gradient(135deg, #00ff55, #00dd44);
      box-shadow: 
        0 0 30px rgba(0, 255, 65, 0.6),
        inset 0 0 20px rgba(255, 255, 255, 0.2);
    }

    .menu-btn.secondary {
      background: linear-gradient(135deg, rgba(0, 170, 255, 0.2), rgba(255, 0, 255, 0.2));
      border-color: #00aaff;
    }

    .menu-btn.secondary:hover {
      border-color: #ff00ff;
      box-shadow: 
        0 0 20px rgba(255, 0, 255, 0.4),
        inset 0 0 20px rgba(255, 0, 255, 0.1);
    }

    .menu-btn.tertiary {
      background: linear-gradient(135deg, rgba(255, 215, 0, 0.1), rgba(255, 100, 0, 0.1));
      border-color: #ffd700;
    }

    .menu-btn.tertiary:hover {
      border-color: #ff6600;
      box-shadow: 
        0 0 20px rgba(255, 215, 0, 0.4),
        inset 0 0 20px rgba(255, 215, 0, 0.1);
    }

    .floating-elements {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 5;
    }

    .floating-element {
      position: absolute;
      width: 4px;
      height: 4px;
      background: #00ff41;
      border-radius: 50%;
      animation: float 6s ease-in-out infinite;
      opacity: 0.6;
    }

    .floating-element:nth-child(2n) {
      background: #00aaff;
      animation-delay: -2s;
    }

    .floating-element:nth-child(3n) {
      background: #ff00ff;
      animation-delay: -4s;
    }

    @keyframes float {
      0%, 100% {
        transform: translateY(0px) rotate(0deg);
        opacity: 0.6;
      }
      50% {
        transform: translateY(-20px) rotate(180deg);
        opacity: 1;
      }
    }

    .status-bar {
      position: fixed;
      bottom: 2rem;
      left: 50%;
      transform: translateX(-50%);
      display: flex;
      gap: 2rem;
      z-index: 10;
    }

    .status-item {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.9rem;
      color: #00aaff;
      opacity: 0.8;
    }

    .status-icon {
      width: 12px;
      height: 12px;
      background: #00ff41;
      border-radius: 50%;
      animation: pulse 2s ease-in-out infinite;
    }

    @keyframes pulse {
      0%, 100% { opacity: 0.6; transform: scale(1); }
      50% { opacity: 1; transform: scale(1.2); }
    }

    .version {
      position: fixed;
      top: 2rem;
      right: 2rem;
      font-size: 0.8rem;
      color: #666;
      z-index: 10;
    }

    .loading-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.9);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      opacity: 0;
      visibility: hidden;
      transition: all 0.5s ease;
    }

    .loading-overlay.active {
      opacity: 1;
      visibility: visible;
    }

    .loading-text {
      font-family: 'Orbitron', monospace;
      font-size: 1.5rem;
      color: #00ff41;
      margin-bottom: 2rem;
      text-align: center;
    }

    .loading-bar {
      width: 300px;
      height: 4px;
      background: rgba(0, 255, 65, 0.2);
      border-radius: 2px;
      overflow: hidden;
    }

    .loading-progress {
      height: 100%;
      background: linear-gradient(90deg, #00ff41, #00aaff);
      border-radius: 2px;
      width: 0%;
      transition: width 0.3s ease;
    }

    .particle-container {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      pointer-events: none;
      z-index: 2;
    }

    @media (max-width: 768px) {
      .menu-container {
        padding: 1rem;
      }
      
      .logo {
        margin-bottom: 1.5rem;
      }
      
      .subtitle {
        margin-bottom: 3rem;
      }
      
      .menu-buttons {
        gap: 1rem;
      }
      
      .menu-btn {
        padding: 0.8rem 1.5rem;
        font-size: 1rem;
      }
      
      .status-bar {
        bottom: 1rem;
        gap: 1rem;
      }
      
      .version {
        top: 1rem;
        right: 1rem;
      }
    }

    @media (max-width: 480px) {
      .menu-btn {
        padding: 0.7rem 1rem;
        font-size: 0.9rem;
      }
      
      .status-bar {
        flex-direction: column;
        gap: 0.5rem;
      }
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>
  
  <div class="particle-container" id="particleContainer"></div>
  
  <div class="floating-elements" id="floatingElements"></div>
  
  <div class="menu-container">
    <h1 class="logo">ASSEMBLY QUEST</h1>
    <p class="subtitle">Simulador de CPU 3D Interativo</p>
    
    <div class="menu-buttons">
      <button class="menu-btn primary" id="playBtn">
        JOGAR
      </button>
      <button class="menu-btn secondary" id="memoryBtn">
        SIMULADOR DE MEMÓRIA
      </button>
      <button class="menu-btn secondary" id="ioBtn">
        SIMULADOR DE I/O
      </button>
    </div>
  </div>
  
  <div class="status-bar">
    <div class="status-item">
      <div class="status-icon"></div>
      <span>Sistema Online</span>
    </div>
    <div class="status-item">
      <div class="status-icon"></div>
      <span>CPU Simulada</span>
    </div>
    <div class="status-item">
      <div class="status-icon"></div>
      <span>Memória Ativa</span>
    </div>
  </div>
  
  <div class="version">v2.0.1</div>
  
  <div class="loading-overlay" id="loadingOverlay">
    <div class="loading-text">Inicializando Sistema...</div>
    <div class="loading-bar">
      <div class="loading-progress" id="loadingProgress"></div>
    </div>
  </div>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
  <script>
    
    window.addEventListener('DOMContentLoaded', () => {
      
      const canvas = document.getElementById('canvas');
      if (!canvas) {
        console.error('Canvas não encontrado!');
        return;
      }
      
      if (typeof THREE === 'undefined') {
        console.error('Three.js não carregado!');
        return;
      }
      
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
      const renderer = new THREE.WebGLRenderer({ canvas: canvas, antialias: true, alpha: true });
      
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setClearColor(0x000000, 0);
      
      
      camera.position.set(0, 0, 15);
      camera.lookAt(0, 0, 0);
      
      
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);
    
      const pointLight1 = new THREE.PointLight(0x00ff41, 1, 50);
      pointLight1.position.set(10, 10, 10);
      scene.add(pointLight1);
      
      const pointLight2 = new THREE.PointLight(0x00aaff, 1, 50);
      pointLight2.position.set(-10, -10, 10);
      scene.add(pointLight2);
      
      const pointLight3 = new THREE.PointLight(0xff00ff, 1, 50);
      pointLight3.position.set(0, 10, -10);
      scene.add(pointLight3);
      
      
      const particleCount = 150;
      const particles = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      const sizes = new Float32Array(particleCount);
      
      for (let i = 0; i < particleCount * 3; i += 3) {
        const radius = 15 + Math.random() * 10;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        
        positions[i] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i + 2] = radius * Math.cos(phi);
        
        const colorChoice = Math.random();
        if (colorChoice < 0.33) {
          colors[i] = 0; colors[i + 1] = 1; colors[i + 2] = 0.25; 
        } else if (colorChoice < 0.66) {
          colors[i] = 0; colors[i + 1] = 0.67; colors[i + 2] = 1; 
        } else {
          colors[i] = 1; colors[i + 1] = 0; colors[i + 2] = 1; 
        }
        
        sizes[i / 3] = Math.random() * 0.5 + 0.3;
      }
      
      particles.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      particles.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      particles.setAttribute('size', new THREE.BufferAttribute(sizes, 1));
      
      const particleMaterial = new THREE.PointsMaterial({
        size: 0.8,
        vertexColors: true,
        transparent: true,
        opacity: 0.7,
        sizeAttenuation: true
      });
      
      const particleSystem = new THREE.Points(particles, particleMaterial);
      scene.add(particleSystem);
      
      
      const geometries = [];
      const geometryTypes = [
        () => new THREE.TorusGeometry(1, 0.3, 16, 100),
        () => new THREE.OctahedronGeometry(1),
        () => new THREE.IcosahedronGeometry(1),
        () => new THREE.TetrahedronGeometry(1),
        () => new THREE.BoxGeometry(1.5, 1.5, 1.5)
      ];
      
      for (let i = 0; i < 8; i++) {
        const geometryType = geometryTypes[Math.floor(Math.random() * geometryTypes.length)];
        const geometry = geometryType();
        
        const colorChoice = Math.random();
        let color, emissive;
        if (colorChoice < 0.33) {
          color = 0x00ff41;
          emissive = 0x00ff41;
        } else if (colorChoice < 0.66) {
          color = 0x00aaff;
          emissive = 0x00aaff;
        } else {
          color = 0xff00ff;
          emissive = 0xff00ff;
        }
        
        const material = new THREE.MeshStandardMaterial({
          color: color,
          emissive: emissive,
          emissiveIntensity: 0.5,
          metalness: 0.8,
          roughness: 0.2,
          transparent: true,
          opacity: 0.6
        });
        
        const mesh = new THREE.Mesh(geometry, material);
        
        const angle = (i / 8) * Math.PI * 2;
        const radius = 8 + Math.random() * 4;
        mesh.position.set(
          Math.cos(angle) * radius,
          (Math.random() - 0.5) * 8,
          Math.sin(angle) * radius
        );
        
        mesh.userData = {
          originalY: mesh.position.y,
          rotationSpeed: {
            x: (Math.random() - 0.5) * 0.02,
            y: (Math.random() - 0.5) * 0.02,
            z: (Math.random() - 0.5) * 0.02
          },
          floatSpeed: Math.random() * 0.01 + 0.005,
          floatAmplitude: Math.random() * 2 + 1
        };
        
        scene.add(mesh);
        geometries.push(mesh);
      }
      
      
      const lineGeometry = new THREE.BufferGeometry();
      const linePositions = [];
      const lineColors = [];
      
      for (let i = 0; i < particleCount; i += 5) {
        const i1 = i;
        const i2 = (i + 5) % particleCount;
        
        const x1 = positions[i1 * 3];
        const y1 = positions[i1 * 3 + 1];
        const z1 = positions[i1 * 3 + 2];
        
        const x2 = positions[i2 * 3];
        const y2 = positions[i2 * 3 + 1];
        const z2 = positions[i2 * 3 + 2];
        
        const distance = Math.sqrt(
          Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2) + Math.pow(z2 - z1, 2)
        );
        
        if (distance < 8) {
          linePositions.push(x1, y1, z1);
          linePositions.push(x2, y2, z2);
          
          const colorChoice = Math.random();
          if (colorChoice < 0.33) {
            lineColors.push(0, 1, 0.25, 0, 1, 0.25);
          } else if (colorChoice < 0.66) {
            lineColors.push(0, 0.67, 1, 0, 0.67, 1);
          } else {
            lineColors.push(1, 0, 1, 1, 0, 1);
          }
        }
      }
      
      lineGeometry.setAttribute('position', new THREE.Float32BufferAttribute(linePositions, 3));
      lineGeometry.setAttribute('color', new THREE.Float32BufferAttribute(lineColors, 3));
      
      const lineMaterial = new THREE.LineBasicMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.3,
        linewidth: 1
      });
      
      const lines = new THREE.LineSegments(lineGeometry, lineMaterial);
      scene.add(lines);
      
      
      const gridHelper = new THREE.GridHelper(30, 30, 0x00ff41, 0x003311);
      gridHelper.material.opacity = 0.2;
      gridHelper.material.transparent = true;
      scene.add(gridHelper);
      
      
      function createFloatingElements() {
        const container = document.getElementById('floatingElements');
        const elementCount = 50;
        
        for (let i = 0; i < elementCount; i++) {
          const element = document.createElement('div');
          element.className = 'floating-element';
          element.style.left = Math.random() * 100 + '%';
          element.style.top = Math.random() * 100 + '%';
          element.style.animationDelay = Math.random() * 6 + 's';
          element.style.animationDuration = (Math.random() * 4 + 4) + 's';
          container.appendChild(element);
        }
      }
      
      
      function createParticles() {
        const container = document.getElementById('particleContainer');
        const particleCount = 30;
        
        for (let i = 0; i < particleCount; i++) {
          const particle = document.createElement('div');
          particle.style.position = 'absolute';
          particle.style.width = Math.random() * 3 + 1 + 'px';
          particle.style.height = particle.style.width;
          particle.style.background = `hsl(${Math.random() * 60 + 120}, 100%, 50%)`;
          particle.style.borderRadius = '50%';
          particle.style.left = Math.random() * 100 + '%';
          particle.style.top = Math.random() * 100 + '%';
          particle.style.opacity = Math.random() * 0.5 + 0.3;
          particle.style.animation = `float ${Math.random() * 10 + 5}s ease-in-out infinite`;
          particle.style.animationDelay = Math.random() * 5 + 's';
          container.appendChild(particle);
        }
      }
      
      
      let time = 0;
      function animate() {
        requestAnimationFrame(animate);
        time += 0.01;
        
        
        particleSystem.rotation.x += 0.0005;
        particleSystem.rotation.y += 0.001;
        particleSystem.rotation.z += 0.0003;
        
        
        const positions = particleSystem.geometry.attributes.position.array;
        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          const z = positions[i + 2];
          
          const radius = Math.sqrt(x * x + y * y + z * z);
          const theta = Math.atan2(y, x) + 0.001;
          const phi = Math.acos(z / radius) + 0.0005;
          
          positions[i] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i + 2] = radius * Math.cos(phi);
        }
        particleSystem.geometry.attributes.position.needsUpdate = true;
        
        
        geometries.forEach((mesh, index) => {
          mesh.rotation.x += mesh.userData.rotationSpeed.x;
          mesh.rotation.y += mesh.userData.rotationSpeed.y;
          mesh.rotation.z += mesh.userData.rotationSpeed.z;
          
          mesh.position.y = mesh.userData.originalY + Math.sin(time * 2 + index) * mesh.userData.floatAmplitude;
          
          
          const pulse = Math.sin(time * 3 + index) * 0.3 + 0.7;
          mesh.material.emissiveIntensity = pulse * 0.5;
          mesh.material.opacity = 0.4 + pulse * 0.3;
          
          
          const angle = time * 0.5 + (index / geometries.length) * Math.PI * 2;
          const radius = 8 + Math.sin(time + index) * 2;
          mesh.position.x = Math.cos(angle) * radius;
          mesh.position.z = Math.sin(angle) * radius;
        });
        
        
        pointLight1.position.x = Math.sin(time) * 15;
        pointLight1.position.y = Math.cos(time * 0.7) * 15;
        pointLight1.intensity = 0.8 + Math.sin(time * 2) * 0.4;
        
        pointLight2.position.x = Math.cos(time * 0.8) * 15;
        pointLight2.position.y = Math.sin(time * 1.2) * 15;
        pointLight2.intensity = 0.8 + Math.cos(time * 2.5) * 0.4;
        
        pointLight3.position.z = Math.sin(time * 0.6) * 15;
        pointLight3.intensity = 0.8 + Math.sin(time * 3) * 0.4;
        
        
        gridHelper.rotation.y += 0.001;
        
        
        camera.position.x = Math.sin(time * 0.3) * 2;
        camera.position.y = Math.cos(time * 0.2) * 2;
        camera.lookAt(0, 0, 0);
        
        renderer.render(scene, camera);
      }
      
      
      function showLoading() {
        const overlay = document.getElementById('loadingOverlay');
        const progress = document.getElementById('loadingProgress');
        
        overlay.classList.add('active');
        
        let currentProgress = 0;
        const interval = setInterval(() => {
          currentProgress += Math.random() * 15;
          if (currentProgress >= 100) {
            currentProgress = 100;
            clearInterval(interval);
            setTimeout(() => {
              overlay.classList.remove('active');
              
              console.log('Carregamento completo!');
            }, 500);
          }
          progress.style.width = currentProgress + '%';
        }, 100);
      }
      
      
      document.getElementById('playBtn').addEventListener('click', () => {
        showLoading();
        
        setTimeout(() => {
          window.location.href = 'game.html';
        }, 2000);
      });
      
      document.getElementById('memoryBtn').addEventListener('click', () => {
        showLoading();
        
        setTimeout(() => {
          window.location.href = 'memory-simulator.html';
        }, 2000);
      });
      
      document.getElementById('ioBtn').addEventListener('click', () => {
        showLoading();
        
        setTimeout(() => {
          window.location.href = 'io-simulator.html';
        }, 2000);
      });
      
      const tutorialBtn = document.getElementById('tutorialBtn');
      if (tutorialBtn) {
        tutorialBtn.addEventListener('click', () => {
          alert('Tutorial em desenvolvimento!');
        });
      }
      
      const settingsBtn = document.getElementById('settingsBtn');
      if (settingsBtn) {
        settingsBtn.addEventListener('click', () => {
          alert('Configurações em desenvolvimento!');
        });
      }
      
      const aboutBtn = document.getElementById('aboutBtn');
      if (aboutBtn) {
        aboutBtn.addEventListener('click', () => {
          alert('Assembly Quest v2.0.1\n\nUm simulador interativo de CPU em 3D que ensina conceitos de arquitetura de computadores através de programação Assembly.\n\nDesenvolvido com Three.js');
        });
      }
      
      
      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
      
      
      createFloatingElements();
      createParticles();
      animate();
      
      
      const logo = document.querySelector('.logo');
      if (logo) {
        const originalText = logo.textContent;
        logo.textContent = '';
        
        let i = 0;
        const typeWriter = () => {
          if (i < originalText.length) {
            logo.textContent += originalText.charAt(i);
            i++;
            setTimeout(typeWriter, 100);
          }
        };
        
        setTimeout(typeWriter, 1000);
      }
      
      console.log('Assembly Quest Menu carregado com sucesso!');
    }); 
  </script>
</body>
</html>